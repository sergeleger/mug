Introduction to Go
Moncton User Group
15 Mar 2016

Serge Leger
Prototype Developer, National Research Council
@sergeleger

* About Me

- Bachelor of Computer Science from UdM.
- Started my career in 1994 with a small local startup (Dovico)
- Joined the public service in 1998 to help transition internal application to 2000+
- In 2006?, joined National Research Council where I work with researchers in a number of different fields.
- C, C++, PowerBuilder, Perl, MySQL, HTML+Javascript+CSS, Java, Python, Go

* Me and Go

I've been using Go since 2012, started using it professional since early 2013.

Researcher wanted to add server-like features to a C++ application,

### TODO COOL IMAGE OF WHAT?!

So did a quick trial-balloon and rewrote the application in Go,

### TODO chart LOC & Speed results AND unix Socket and TCP servers...

* History

- Started at Google by engineers frustrated with the complexity of C++
- Those engineers are
- Robert Griesemer
- Rob Pike (Unicode?, ...)
- Ken Thompson

* Tutorial

* Hello World

.play 01-hello-world.go

### Introduce the package export rules
### Introduce the camel-case

* Types and Variables

Go has many simple types:

  int, int8, int16, int32, int64
  uint, uint8, uint16, uint32, uint64, uintptr
  float32, float64
  complex64, complex128
  bool, byte, rune, string, error

But these are the ones you'll use most often:

  int, float64, bool, byte, string, error

Note: `int` and `uint` are the natural or most efficient size for integers on a particular platform, either 32 or 64 bits.

* Variable Declaration

.play 02-hello-world-with-types.go

### Use this page to show:
## - implicit type declaration
## - zero value for types
## - short variable declaration
## - some other types?
## - unused variables

* Celcius & Farenheit

.play 03-simple-temp.go

## - talk about utf8 program files and unicode strings

* Control Structures

* If statement

A simple `if` statement:

    if x > 0 {
        return y
    }

- Braces are mandatory
- The expression must evaluate to a boolean
- There is also an optional `else` statement

    if x > 0 {
        return y
    } else {
        return z
    }

* If statement (continued)

- Cascading `if`/`else` statements

    if x > 0 {
        return y
    } else if x < 0 {
        return z
    } else if x == 0 {
        return x
    } else {
        // Can't reach this condition?
    }

- If statements can also contain an initialization statement:

    if x = someFunction(); x == 0 {
        return z
    }

* If statement (playground)

.play 04-if.go

* Switch statement

A simple C-like `switch` statement:

    switch coinFlip() {
    case "heads":
        heads++

    case "tails":
        tails++

    default:
        fmt.Println("landed on edge!")
    }

- No `break` statement required, by default cases do not fall through.
- Use the `fallthrough` statement if that behavior is needed.

* Switch statement (continued)

- Instead of using `fallthrough`, case statements can be combined:

    switch dayOfWeek {
    case "Saturday", "Sunday":
        fmt.Println("It's the weekend!")

    default:
        fmt.Println("Get up and go to work.")
    }

* Switch statement (continued)

- The switch's expression is optional, so a switch statement can be used to replace long and complex `if`/`else` cascades:

    switch {
    case dayOfWeek == "Saturday" || dayOfWeek == "Sunday":
        fmt.Println("It's the weekend!")

    case dayOfWeek == "Wednesday" && weekNumber % 2 == 0:
        fmt.Println( "Payday!")

    default:
        fmt.Println("Get up and go to work.")
    }

* For statement

Go has a single loop statement; the `for` loop has multiple forms:

    // C style
    for initialization; condition; post {
    }

    for i := 0; i<10; i++ {
    }

Both, _initialization_ and _post_ are optional:

    // A traditional "while" loop
    for condition {
    }

_condition_ is also optional and defaults to `true`:

    // an infinite loop
    for {
    }

* For statement (continued)

- `break` statement terminates the execution of the inner-most loop
- `continue` statement begins the next iteration of the inner-most loop
- There is also a "for-each" operator: `range` which operates on arrays, slices, maps and channels.

    dwarves := [7]string{"Doc", "Grumpy", "Happy", "Sleepy", "Bashful", "Sneezy", "Dopey"}
    for index, name := range arr {
        fmt.Println( index, name )
    }

* Constants, Custom Types, and Enumerated Types

* Constants

Constants are defined with the `const` keyword:

    const Pi = 3.141592
    const (
        a = 1
        b = 2
        c = 3
        d = 4
    )
    const a, b, c, d = 1, 2, 3, 4

Go provides the `iota` constant generator to help construct constant values:

    const (
        Monday = iota
        Tuesday
        Wednesday
        Thursday
        //...
    )

* Custom Types

Using the `type` keyword we can create custom types:

    type Color uint64

    // Same rules apply, you cannot assign a Color value to an uint64 variable
    var red Color = 1
    var value uint64
    value = red // compilation error

* Enumerated Types

By combining constants and custom types we can create enumerated types:

    type Color uint64

    const (
        Red Color = iota
        Green
        Blue
    )

or bit masks (from Go's `net` package)

    type Flags uint
    const (
        FlagUp Flags = 1 << iota
        FlagBroadcast
        FlagLoopback
        FlagPointToPoint
        FlagMulticast
    )

* Composite Types

* Arrays

Arrays is a *fixed-length* sequence of zero or more elements. Since they are fixed-length arrays are rarely used.

    // An IP address
    var ip [4]byte
    ip[0] = 192
    ip[1] = 168
    ip[2] = 1
    ip[3] = 1

    // The same declaration
    var ip = [4]byte{ 192, 168, 1, 1 }

    // Another, the array size is calculated by the compiler
    var ip = [...]byte{ 192, 168, 1, 1 }

- The built-in `len` function returns the number of elements in the array.
- Arrays are passed by value, so use with care.

* Arrays (playground)

.play 05-arrays.go

* Slices

Slices represents variable-length sequences, like arrays, slices are indexable and have a length.

    // An IP address, using slices
    var ip []byte
    ip = append(ip, 192)
    ip = append(ip, 168)
    ip = append(ip, 1)
    ip = append(ip, 1)

    // The same declaration
    var ip = []byte{192, 168, 1, 1}

* Slice Construction

A slice can be constructed using the `make` built-in function, providing a length and a default capacity.

    ids := make([]int, 5)
    ids[0] = 2
    ids[1] = 15

    ids = make([]int, 5, 10)
    ids[0] = 1
    ids[4] = 16
    ids[5] = 42 // panics: overflow error
    ids = append(ids, 42)
    fmt.Println(ids[5] == 42) // prints true

Slices are backed by an array which the Go runtime, talk about the length and capacity and pointer to array.

- The built-in `make` function can be used to create a new slice.

* Slices (playground)

.play 06-slices.go

- The built-in `len` function returns the length of the slice.
- The built-in `cap` function returns the current capacity of the slice.

* Slice Operators

Slices can be created from existing slices and arrays:

.play 07-slices-op.go

* Maps

Maps are Go's implementation of associative arrays.

    var capitals = map[string]string{
        "NB": "Fredericton",
        "NS": "Halifax",
        "QC": "Quebec",
    }
    fmt.Println(capitals["NB"])
    fmt.Println(capitals["ON"])

    // Check if a key exists
    city, ok := capitals["ON"]
    if ok {
        fmt.Println("Ontario's capital is", city)
    }

* Map Construction

Maps must be created using the `make` built-in function:

    capitals := make(map[string]string, 13) // initial space for 13 provinces
    capitals["NB"] = "Fredericton"
    capitals["ON"] = "Toronto"
    // ...

* Struct Types

A structures is a sequence of fields, each of which has a name and a type.

    type Person struct {
        Name   string
        Street string
        City   string
    }

    var bob Person
    bob.Name = "Bob"
    bob.Street = "123 Street"
    bob.City = "Somewhere, OH"

    // Using struct literals
    var charles = Person{
        Name:   "Chuck",
        Street: "456 Street",
        City:   "Somecity, ME",
    }

* Embedding structures

Go does not have inheritance, instead, we use type composition:

    type Employee struct {
        Person
        Id string
    }

    var bob Employee
    bob.Id = "123"
    bob.Name = "Bob"
    bob.Street = "123 Street"
    bob.City = "Somewhere, OH"

    // Using struct literals
    var charles = Employee{
        Person: Person{
            Name:   "Chuck",
            Street: "456 Street",
            City:   "Somecity, ME",
        },
        Id: "456",
    }

* Functions

* Functions

Function declaration has a name, a list of parameters, an optional list of results, and a body:

    func name(parameter-list) (result-list) {
        body
    }

    func max(x int, y int) int {
        if x > y {
            return x
        } else {
            return y
        }
    }

- Function parameters can be simplified to avoid repeating types:

    func max(x, y int) int { ... }

* Functions with multiple return values

Functions can return multiple values, this is often used to return error conditions.

    func swap(x, y int) (int, int) {
        t := x
        x = y
        y = t
        return x, y
    }

    func safeSwap(x, y int) (int, int, error) {
        if x < 0 || y < 0 {
            return x, y, errors.New("can't swap negative numbers")
        }
        return y, x, nil
    }

* Functions are first-class values

    func square(n int) int { return n*n }
    func negative(n int) int { return -n }
    func product( n, m int) int { return n*m }

    f := square
    fmt.Println(f(5), square(5))

    f = negative
    fmt.Println(f(5))

    func newProductFunc( n int ) func(int) int {
        return func(m int) int {
            return n*m
        }
    }

* Variadic functions

    func max( numbers ...int ) int {
        m := 0
        for _, v := range numbers {
            if v > m {
                m = v
            }
        }

        return m
    }

* Deferred Functions

The execution of a function can be deferred until the enclosing function returns. This is normally used with paired operations like open and close or lock and unlock.

    func max(x, y int) int {
        defer fmt.Printf("Input parameters: max(%d, %d)\n", x, y)
        if x>y {
            return x
        }
        fmt.Println( "Returning with max=Y=", y)
        return y
    }

    func readFile(filename string) {
        fh, err := os.Open(filename)
        if err != nil {
            return
        }
        defer fh.Close()

        // ... process file ...
    }

* Objects

* Objects

In Go an object is simply a variable or value that has methods, a method is a function associated with a particular type.

- There is no inheritance in Go instead types are composed.
- There are no constructors or destructors either.

Here is generic method definition:

    func (receiver) name(parameter-list) (result-list) {
        body
    }

* Objects (continued)

    type Point struct {
        X, Y float64
    }

    func Distance(p, q Point) float64 {
        return math.Hypot(p.X-q.X, p.Y-q.Y)
    }

    func (this Point) Distance(q Point) float64 {
        return math.Hypot(this.X-q.X, this.Y-q.Y)
    }

* Methods with Pointer Receivers

The `Point.Distance` method uses a pass-by-value receiver meaning that any changes made to the `point` variable will be lost. Instead we can use a *pointer receiver*

    func (point *Point) ScaleBy(n float64) {
        point.X *= n
        point.Y *= n
    }

    point.ScaleBy(3)
    fmt.Println(point)

* Object Composition

    type ColoredPoint struct {
        Point
        Color string
    }

    cpRed := ColoredPoint{ Point{1,2}, "red" }
    cpBlue := ColoredPoint{ Point{2,3}, "blue" }

    fmt.Println(cpRed.Distance(Point{3,4}))
    fmt.Println(cpRed.Point.Distance(Point{3,4}))
    fmt.Println(cpRed.Distance(cpBlue)) // compile error


* Interfaces

* Interfaces

Interfaces in Go are similar to interfaces from Java. Here is a generic interface definition:

    type Name interface {
        // List of functions
        fnName1(parameter-list) (result-list)
        fnName2(parameter-list) (result-list)
        fnName3(parameter-list) (result-list)

        // List of other interfaces
        InterfaceName2
    }

- There is no requirement to declare that an object _implements_ an interface. The compiler ensures that an object properly implements the interface.
- Interfaces in Go are normally small with only a few methods.

* Interfaces from Go's io package

    type Reader interface {
        Read(p []byte) (n int, err error)
    }

    type Closer interface {
        Close() error
    }

    // Interface embedding
    type ReadCloser interface {
        Reader
        Closer
    }

* Implementation of the io.Reader interface

    type myReader uint8

    func (r myReader) Read(p []byte) (int, error) {
        for i := range p {
            p[i] = byte(r)
        }
        return len(p), nil
    }

    func main() {
        var reader myReader = 65
        io.Copy(os.Stdout, reader)

        // io.LimitedReader{r, 10}
    }

* Interfaces (playground)

    type Shape interface {
        Area() float64
    }

    type Square struct { side float64 }
    type Circle struct { radius float64 }

    func (sq *Square) Area() float64 { return sq.side * sq.side }
    func (c *Circle) Area() float64 { return math.PI * math.Pow(c.radius, 2) }


* Empty Interface

An empty interface is an interface with no methods -- meaning that everything in Go satisfies the empty interface. This is similar to Java's `Object`. The interface type is written `interface{}`:

    var f interface{} = 1.0

    func describe(v interface{}) { fmt.Printf( "(%T, %v)\n", v, v) }

    var f32 float32 = 21
    var f64 float64 = 42
    var i int = 10
    var s string = "A string"

    describe(f32)
    describe(f64)
    describe(i)
    describe(s)

* Type Assertions

Sometimes it is useful to either convert an interface to its underlying type or to convert it to another interface.

    func readAndClose( r io.Reader) {
        // read data from r

        // Close the file if it implements the io.Closer interface

        // Type Assertion
        closer := r.(io.Closer)
        if ok {
            fmt.Println( "Closing the file" )
            closer.Close()
        }
    }

    func main() {
        var reader myReader = 65
        readAndClose(reader)

        readAndClose(os.Stdin)
    }

* From Type Assertions to Type Switches

    func double(x interface{}) interface{} {
        if x, ok := x.(int); ok {
            return x*2
        } else if x, ok := x.(*int); ok {
            return (*x) * 2
        } else if x, ok := x.(float32); ok {
            return x*2
        } else if x, ok := x.(float64); ok {
            return x*2
        } else {
            log.Fatalf("unsupported type: %T", x)
        }
    }

    func main() {
        fmt.Println( double(float32(5.5)) )
        fmt.Println( double(float64(5.5)) )
        fmt.Println( double(int(5)) )
        fmt.Println( double(uint(5)) )

        var i := 15
        fmt.Println( double(i) )
        fmt.Println( double(&i) )
    }

* Type Switches

    func double(x interface{} ) interface{} {
        switch x := x.(type) {
        case int:
            return x*2
        case float32:
            return x*2
        case float64:
            return x*2
        case *int:
            return *x * 2

        default:
            log.Fatalf("unsupported type: %T", x)
        }
    }

    func main() {
        fmt.Println( double(float32(5.5)) )
        fmt.Println( double(float64(5.5)) )
        fmt.Println( double(int(5)) )
        fmt.Println( double(uint(5)) )

        var i := 15
        fmt.Println( double(i) )
        fmt.Println( double(&i) )
    }

* Concurrency

* Go supports concurrency

Go provides:

- concurrent execution (goroutines)
- synchronization and messaging (channels)
- multi-way concurrent control (select)

* Concurrency vs Parallelism

Concurrency is about dealing with lots of things at once.

Parallelism is about doing lots of things at once.

Concurrency is about structure, parallelism is about execution.

Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.

* Goroutines are not threads

They're a bit like threads, but cheaper. Small and resizeable stacks (2KB) versus 1MB for threads.

Common to launch a large number of goroutines during the life of an application.

The Go runtime multiplexes goroutines across OS threads.

* Goroutines (launch and forget)

    func say(str string) {
        fmt.Println( str )
    }

    func main() {
        go say("Hello, World!")
        say("All Done!")

        time.Sleep(2*time.Second)
    }


- Goroutines definition
- ping/pong example
- buffered and unbuffered channels
- select statment
- mention other types of `sync` locking
- relations with threads (large 2MB stack vs 2KB for a goroutine)
- Goroutine scheduling is done by the Go runtime

* Packages

- import path
- `init()` function

* Go tools

- go run
- go fmt
- go test

* References

- The Go Programming Language, Alan A. A. Donovan & Brian W. Kernighan
- https://tour.golang.org/
- https://golang.org/doc/effective_go.html
- https://golang.org/ref/spec
